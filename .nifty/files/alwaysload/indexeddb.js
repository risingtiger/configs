let _db=null;let _localdb_objectstores=[];let _db_name="";let _db_version=0;const Init=async(localdb_objectstores,db_name,db_version)=>{_localdb_objectstores=localdb_objectstores;_db_name=db_name;_db_version=db_version};const GetDB=()=>new Promise(async(res,_rej)=>{_db=await openindexeddb();res(_db)});const GetOne=(objectstore_name,id)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const transaction=_db.transaction(objectstore_name,'readonly');const objectStore=transaction.objectStore(objectstore_name);const result=await GetOne_S(objectStore,id);res(result)});const GetAll=(objectstore_names)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const returns=new Map();const transaction=_db.transaction(objectstore_names,'readonly');const promises=[];for(const objectstore_name of objectstore_names){const objectstore=transaction.objectStore(objectstore_name);promises.push(GetAll_S(objectstore))}const r=await Promise.all(promises);if(r===null){res(new Map());return}for(let i=0;i<r.length;i++){returns.set(objectstore_names[i],r[i])}res(returns)});const GetRangeAll=(objectstore_names,keys,lower_bounds,upper_bounds)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const returns=new Map();const transaction=_db.transaction(objectstore_names,'readonly');const promises=[];let i=0;for(const objectstore_name of objectstore_names){const objectstore=transaction.objectStore(objectstore_name);promises.push(GetRangeAll_S(objectstore,keys[i],lower_bounds[i],upper_bounds[i]));i++}const r=await Promise.all(promises);if(r===null){res(new Map());return}for(let i=0;i<r.length;i++){returns.set(objectstore_names[i],r[i])}res(returns)});const ClearAll=(objectstore_name)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const tx=_db.transaction(objectstore_name,'readwrite');const objstore=tx.objectStore(objectstore_name);const request=objstore.clear();request.onerror=async()=>{redirect_from_error("ClearAll: clear failed")};tx.onerror=async()=>{redirect_from_error("ClearAll: tx error")};tx.oncomplete=()=>{res(1)}});const AddOne=(objectstore_name,data)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const transaction=_db.transaction(objectstore_name,'readwrite');const objectstore=transaction.objectStore(objectstore_name);const keystring=await AddOne_S(objectstore,data);res(keystring)});const PutOne=(objectstore_name,data)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const transaction=_db.transaction(objectstore_name,'readwrite');const objectstore=transaction.objectStore(objectstore_name);const keystring=await PutOne_S(objectstore,data);res(keystring)});const DeleteOne=(objectstore_name,id)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const transaction=_db.transaction(objectstore_name,'readwrite');const objectstore=transaction.objectStore(objectstore_name);const r=await DeleteOne_S(objectstore,id);res(r)});const PutMany=(store_names,datas)=>new Promise(async(resolve,_reject)=>{if(_db===null){await GetDB()}if(!datas.some((d)=>d.length>0)){resolve();return}const tx=_db.transaction(store_names,"readwrite",{durability:"relaxed"});let are_there_any_put_errors=false;for(let i=0;i<datas.length;i++){if(datas[i].length===0)continue;const os=tx.objectStore(store_names[i]);for(let ii=0;ii<datas[i].length;ii++){const db_put=os.put(datas[i][ii]);db_put.onerror=(_event)=>are_there_any_put_errors=true}}tx.oncomplete=(_event)=>{if(are_there_any_put_errors)redirect_from_error("PutMany error");resolve()};tx.onerror=(_event)=>{redirect_from_error("PutMany error")}});const DeleteMany=(store_names,datas)=>new Promise(async(resolve,_reject)=>{if(_db===null){await GetDB()}if(!datas.some((d)=>d.length>0)){resolve();return}const tx=_db.transaction(store_names,"readwrite",{durability:"relaxed"});let are_there_any_delete_errors=false;for(let i=0;i<datas.length;i++){if(datas[i].length===0)continue;const os=tx.objectStore(store_names[i]);for(let ii=0;ii<datas[i].length;ii++){const db_delete=os.delete(datas[i][ii]);db_delete.onerror=(_event)=>are_there_any_delete_errors=true}}tx.oncomplete=(_event)=>{if(are_there_any_delete_errors)redirect_from_error("DeleteMany error");resolve()};tx.onerror=(_event)=>{redirect_from_error("DeleteMany error")}});const Count=(objectstore_name)=>new Promise(async(res,_rej)=>{if(_db===null){await GetDB()}const transaction=_db.transaction(objectstore_name,'readonly');const objectstore=transaction.objectStore(objectstore_name);let count=0;const request=objectstore.count();request.onsuccess=(ev)=>count=Number(ev.target.result);request.onerror=async(_ev)=>{await redirect_from_error("Count: request error")};transaction.onerror=async()=>{await redirect_from_error("Count: tx error")};transaction.oncomplete=()=>{res(count)}});const GetAll_S=(objectstore)=>new Promise((res,_rej)=>{const request=objectstore.getAll();request.onsuccess=(ev)=>{const records=ev.target.result;res(records)};request.onerror=async(_ev)=>{redirect_from_error("GetAll_S: request error")}});const GetRangeAll_S=(objectstore,key,lower_bound,upper_bound)=>new Promise((res,_rej)=>{const key_range=IDBKeyRange.bound(lower_bound,upper_bound);const index=objectstore.index(key);const request=index.getAll(key_range);request.onsuccess=(ev)=>{const records=ev.target.result;res(records)};request.onerror=async(_ev)=>{redirect_from_error("GetRangeAll_S: request error")}});const GetOne_S=(objectstore,id)=>new Promise((res,_rej)=>{const request=objectstore.get(id);request.onsuccess=(ev)=>res(ev.target.result);request.onerror=async(_ev)=>{redirect_from_error("GetOne_S: request error")}});const AddOne_S=(objectstore,data)=>new Promise((res,_rej)=>{const request=objectstore.add(data);request.onsuccess=(ev)=>res(ev.target.result);request.onerror=async(_ev)=>{redirect_from_error("AddOne_S: request error")}});const PutOne_S=(objectstore,data)=>new Promise((res,_rej)=>{const request=objectstore.put(data);request.onsuccess=(ev)=>res(ev.target.result);request.onerror=async(_ev)=>{redirect_from_error("PutOne_S: request error")}});const DeleteOne_S=(objectstore,id)=>new Promise((res,_rej)=>{const request=objectstore.delete(id);request.onsuccess=(ev)=>res(ev.target.result);request.onerror=async(ev)=>{redirect_from_error("DeleteOne_S: request error")}});const TXResult=(tx)=>new Promise((res,_rej)=>{tx.onerror=async()=>{redirect_from_error("TXResult: tx error")};tx.oncomplete=()=>{res(1)};tx.onabort=async()=>{redirect_from_error("TXResult: tx aborted")}});const openindexeddb=()=>new Promise(async(res,rej)=>{let dbconnect=indexedDB.open(_db_name,_db_version);dbconnect.onerror=async(_event)=>{await redirect_from_error("openindexeddb: connection error");rej()};dbconnect.onsuccess=async(event)=>{const db=event.target.result;res(db)};dbconnect.onupgradeneeded=(event)=>{const db=event.target.result;_localdb_objectstores.forEach((dc)=>{if(!db.objectStoreNames.contains(dc.name)){const opts={keyPath:'id'};if(dc.auto_increment===true){opts.autoIncrement=true}const objectStore=db.createObjectStore(dc.name,opts);(dc.indexes||[]).forEach((prop)=>{objectStore.createIndex(prop,prop,{unique:false})})}})}});async function redirect_from_error(errmsg){$N.Unrecoverable("Error","Error in IndexedDB","Reset App","ixe",errmsg,null)}export{Init};if(!window.$N){window.$N={}}window.$N.IDB={GetDB,GetOne,GetAll,GetRangeAll,ClearAll,AddOne,PutOne,PutMany,DeleteMany,DeleteOne,Count,GetOne_S,GetAll_S,GetRangeAll_S,AddOne_S,PutOne_S,DeleteOne_S,TXResult}
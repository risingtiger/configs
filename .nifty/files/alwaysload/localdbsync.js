let DBNAME="";let DBVERSION=0;const COLLECTION_TS='localdbsync_collections_ts';let _syncobjectstores=[];let _activepaths=[];let _a_millis=0;const Init=(localdb_objectstores_tosync,db_name,db_version)=>{_a_millis=Math.floor(Date.now()/1000);DBNAME=db_name;DBVERSION=db_version;{const objectstores_tosync_names=localdb_objectstores_tosync.map((item)=>item.name);const localstorage_syncobjectstores=JSON.parse(localStorage.getItem(COLLECTION_TS)||"[]");const synccollections_not_in_localstorage=objectstores_tosync_names.filter((name)=>!localstorage_syncobjectstores.find((item)=>item.name===name));synccollections_not_in_localstorage.forEach((name)=>{localstorage_syncobjectstores.push({name,ts:null})});_syncobjectstores=localstorage_syncobjectstores.map((dc,_i)=>({name:dc.name,ts:dc.ts,lock:false,indexes:localdb_objectstores_tosync.find((l_ots)=>l_ots.name===dc.name)?.indexes||null}));localStorage.setItem(COLLECTION_TS,JSON.stringify(localstorage_syncobjectstores));_activepaths=_syncobjectstores.filter((so)=>so.ts!==null&&so.ts>0).map((so)=>parse_into_pathspec(so.name))}return true};const RunSyncFromEvent=async(eventname,event)=>new Promise(async(res,rej)=>{if(eventname==="visible"||eventname==="15interval"){if(_activepaths.length===0){res();return}const r=await datasetter(_activepaths,{},true).catch(()=>null);if(r===null){rej();return}res();return}if(eventname==="datasync_doc_patch"||eventname==="datasync_doc_delete"){if(!event||!event.paths||!event.data){res();return}const ps=parse_into_pathspec(event.paths[0]);if(!ps.syncobjectstore){res();return}if(eventname==="datasync_doc_delete"){await $N.IDB.DeleteOne(ps.syncobjectstore.name,event.data.id)}else{await write_to_indexeddb_store([ps.syncobjectstore],[[event.data]])}res();return}if(eventname==="datasync_collection"){if(!event||!event.paths||!event.paths.length){console.error('RunSyncFromEvent: missing event, event.paths or event.paths.length');return}const ssepathspecs=event.paths.map((sp)=>parse_into_pathspec(sp));const pathspecs=_activepaths.filter((aps)=>ssepathspecs.find((sp)=>sp.collection===aps.collection&&sp.docid===aps.docid&&sp.subcollection===aps.subcollection));if(pathspecs.length===0){res();return}const r=await datasetter(pathspecs,{},true).catch(()=>null);if(r===null){rej();return}res();return}});const PreloadObjectStores=(names)=>new Promise(async(res,rej)=>{const pathspecs=names.map((name)=>parse_into_pathspec(name));const newpathspecs=pathspecs.filter((pathspec)=>!_activepaths.some((activePath)=>activePath.collection===pathspec.collection&&activePath.docid===pathspec.docid&&activePath.subcollection===pathspec.subcollection));if(newpathspecs.length===0){res(1);return}const r=await datasetter(newpathspecs,{},false).catch(()=>null);if(r===null){rej();return}_activepaths=[..._activepaths,...newpathspecs];res(1)});const Add=async(pathstr,data)=>{const pathspec=parse_into_pathspec(pathstr);if(!pathspec||!pathspec.docid||!pathspec.syncobjectstore){console.error('Add: invalid pathspec');return}data.ts=Math.floor(Date.now()/1000);data.id=crypto.randomUUID();const cname=pathspec.syncobjectstore.name;const body={path:cname,data,suppress_sse:true};const opts={method:'POST',body:JSON.stringify(body)};const r=await $N.FetchLassie('/api/firestore_add',opts,null);if(!r.ok){redirect_from_error("Add: FetchLassie Failed");return}await $N.IDB.PutOne(cname,data)};const Patch=async(pathstr,newpartialdata)=>{const pathspec=parse_into_pathspec(pathstr);if(!pathspec||!pathspec.docid||!pathspec.syncobjectstore){console.error('Patch: invalid pathspec');return}const cname=pathspec.syncobjectstore.name;const ts=Math.floor(Date.now()/1000);const existingdata=await $N.IDB.GetOne(cname,pathspec.docid);const oldts=existingdata.ts;const newdata=merge_new_to_existing(existingdata,{...newpartialdata,ts});const body={path:pathspec.path,oldts,newdata:change_newdata_for_firestore_update(newdata),suppress_sse:true};const opts={method:"POST",body:JSON.stringify(body)};const r=await $N.FetchLassie('/api/firestore_patch',opts,null);if(!r.ok||r.data.code!==1){redirect_from_error("Patch FetchLassie Failed. Server code: "+r.data.code);return}await $N.IDB.PutOne(cname,newdata)};const Delete=async(pathstr)=>{const pathspec=parse_into_pathspec(pathstr);if(!pathspec||!pathspec.docid||!pathspec.syncobjectstore){console.error('Delete: invalid pathspec');return}const cname=pathspec.syncobjectstore.name;const existingdata=await $N.IDB.GetOne(cname,pathspec.docid);const oldts=existingdata.ts;const newts=Math.floor(Date.now()/1000);const body={path:pathspec.path,oldts,ts:newts,suppress_sse:true};const opts={method:'POST',body:JSON.stringify(body)};const r=await $N.FetchLassie('/api/firestore_delete',opts,null);if(!r.ok){redirect_from_error("Delete FetchLassie Failed");return}if(r.data?.code===11){await $N.IDB.PutOne(cname,r.data.data);redirect_from_error("Delete sorta failed. Was newer at server");return}await $N.IDB.DeleteOne(cname,pathspec.docid)};const datasetter=(pathspecs,opts,force_refresh_syncobjectstores=false)=>new Promise(async(res,rej)=>{opts=opts||{};const paths_tosync=pathspecs.filter((p)=>p.syncobjectstore.ts===null||force_refresh_syncobjectstores);const syncobjectstores_tosync_withduplicates=paths_tosync.map((p)=>p.syncobjectstore);const syncobjectstores_tosync=syncobjectstores_tosync_withduplicates.filter((item,index)=>syncobjectstores_tosync_withduplicates.indexOf(item)===index);const syncobjectstores_tosync_unlocked=syncobjectstores_tosync.filter((dc)=>!dc.lock);const syncobjectstores_tosync_locked=syncobjectstores_tosync.filter((dc)=>dc.lock);{if(syncobjectstores_tosync_unlocked.length){const rs=await load_into_syncobjectstores(syncobjectstores_tosync_unlocked).catch(()=>null);if(rs===null){rej();return}}if(syncobjectstores_tosync_locked.length){await new Promise((resolve_inner)=>{const intrvl=setInterval(()=>{if(syncobjectstores_tosync_locked.every((dc)=>!dc.lock)){clearInterval(intrvl);resolve_inner(1)}},10)})}}res(1)});function parse_into_pathspec(path){const p=path.split('/');const collection=p[0];const docid=p[1]||null;const subcollection=docid&&p[2]?p[2]:null;const syncobjectstore=_syncobjectstores.find((dc)=>dc.name===collection);return{path,p,collection,docid,subcollection,syncobjectstore}}const load_into_syncobjectstores=(syncobjectstores)=>new Promise(async(res,rej)=>{syncobjectstores.forEach((dc)=>dc.lock=true);const runidstring=Math.random().toString(15).substring(2,12);let continue_calling=true;const paths=syncobjectstores.map((dc)=>dc.name);const tses=syncobjectstores.map((dc)=>dc.ts||null);const body={runid:runidstring,paths,tses};while(continue_calling){const r=await $N.FetchLassie('/api/firestore_get_batch',{method:"POST",body:JSON.stringify(body)},{});if(!r.ok){cleanup();await remove_all_records_after_ts(syncobjectstores);rej();return}for(let i=0;i<paths.length;i++){if(r.data[i].docs.length===0)continue;await write_to_indexeddb_store([syncobjectstores[i]],[r.data[i].docs])}continue_calling=r.data.every((rr)=>rr.isdone)?false:true}const newts=Math.floor(Date.now()/1000);syncobjectstores.forEach((dc)=>dc.ts=newts);localStorage.setItem(COLLECTION_TS,JSON.stringify(_syncobjectstores.map((dc)=>({name:dc.name,ts:dc.ts}))));cleanup();res(1);function cleanup(){continue_calling=false;syncobjectstores.forEach((dc)=>dc.lock=false)}});const write_to_indexeddb_store=(syncobjectstores,datas)=>new Promise(async(resolve,_reject)=>{const deleteobjectstoreindexes=[];syncobjectstores.forEach((dc,i)=>{if(dc.name==='__deleted_docs')deleteobjectstoreindexes.push(i)});const delete_syncobjectstores=deleteobjectstoreindexes.map((i)=>syncobjectstores[i]);const delete_datas=deleteobjectstoreindexes.map((i)=>datas[i]);const normal_syncobjectstores=syncobjectstores.filter((_,i)=>!deleteobjectstoreindexes.includes(i));const normal_datas=datas.filter((_,i)=>!deleteobjectstoreindexes.includes(i));const promises=[];promises.push($N.IDB.PutMany(normal_syncobjectstores.map((dc)=>dc.name),normal_datas));promises.push($N.IDB.DeleteMany(delete_syncobjectstores.map((dc)=>dc.name),delete_datas));await Promise.all(promises);resolve()});async function redirect_from_error(errmsg){$N.Unrecoverable("Error","Error in LocalDBSync","Reset App","lde",errmsg,null)}const remove_all_records_after_ts=async(syncobjectstores)=>{const db=await $N.IDB.GetDB();for(const so of syncobjectstores){await new Promise((resolve)=>{const ts=so.ts||0;let tx=db.transaction(so.name,'readwrite');const os=tx.objectStore(so.name);const idx=os.index('ts');const range=IDBKeyRange.lowerBound(ts,true);const req=idx.openCursor(range);req.onsuccess=()=>{const cursor=req.result;if(!cursor)return;try{cursor.delete()}catch{}cursor.continue()};req.onerror=()=>{};tx.oncomplete=()=>resolve();tx.onerror=()=>resolve();tx.onabort=()=>resolve()})}};function merge_new_to_existing(existing,newpartial){const merged={...existing};for(const key in newpartial){if(!Object.prototype.hasOwnProperty.call(newpartial,key)){continue}const newvalue=newpartial[key];if(newvalue===undefined){continue}if(newvalue===null){merged[key]=null;continue}if(Array.isArray(newvalue)){merged[key]=newvalue.slice();continue}if(typeof newvalue==='object'){if(newvalue.__path){merged[key]=newvalue;continue}const isplainobject=Object.prototype.toString.call(newvalue)==='[object Object]';if(isplainobject){const existingvalue=merged[key];const base=existingvalue&&typeof existingvalue==='object'&&!Array.isArray(existingvalue)?{...existingvalue}:{};merged[key]=merge_new_to_existing(base,newvalue);continue}merged[key]=newvalue;continue}merged[key]=newvalue}return merged}function change_newdata_for_firestore_update(newdata){const firestore_ready_data={};for(const key in newdata){if(typeof newdata[key]==='object'&&newdata[key]!==null){if(newdata[key].__path){firestore_ready_data[key]=newdata[key]}else if(Array.isArray(newdata[key])){firestore_ready_data[key]=newdata[key]}else{for(const subkey in newdata[key]){firestore_ready_data[`${key}.${subkey}`]=newdata[key][subkey]}}}else{firestore_ready_data[key]=newdata[key]}}return firestore_ready_data}export{Init,PreloadObjectStores,RunSyncFromEvent,Add,Patch,Delete}